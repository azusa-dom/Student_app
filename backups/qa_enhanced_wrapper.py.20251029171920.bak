#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""qa_enhanced_wrapper_v2.py - æ™ºèƒ½ç­”æ¡ˆç”Ÿæˆå™¨

æ ¸å¿ƒæ”¹è¿›:
1. æ™ºèƒ½æŸ¥è¯¢éªŒè¯ - è¯†åˆ«æ— æ„ä¹‰æŸ¥è¯¢
2. æ”¹è¿›çš„æ„å›¾è¯†åˆ« - æ›´ç²¾ç¡®çš„ç†è§£
3. æ›´å¥½çš„ Prompt - å‘Šè¯‰ LLM å¦‚ä½•æ€è€ƒ
4. è´¨é‡æ£€æŸ¥ - éªŒè¯ç­”æ¡ˆç›¸å…³æ€§
"""

import os, sys, json, time, logging, re
from functools import lru_cache
from pathlib import Path
from typing import Any, Dict, List, Optional

ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT))
sys.path.insert(0, str(ROOT / "scripts"))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("qa_wrapper_v2")

# å¯¼å…¥ä¾èµ–
try:
    from scripts.llm_client import chat_with_groq, is_configured as groq_configured
    logger.info("âœ… Using llm_client.py")
except Exception:
    try:
        from scripts.groq_client import chat_with_groq, is_configured as groq_configured
        logger.info("âœ… Using groq_client.py")
    except Exception:
        def groq_configured(): return False
        def chat_with_groq(*a, **k): raise Exception("LLM not available")

try:
    from scripts.enhanced_retriever import EnhancedRetriever
    HAVE_RETRIEVER = True
except Exception:
    HAVE_RETRIEVER = False

try:
    from scripts.web_search import search_web
    HAVE_WEB_SEARCH = True
except Exception:
    HAVE_WEB_SEARCH = False

PROGRAMS_PATH = ROOT / "public/data/ucl_programs.json"
SERVICES_PATH = ROOT / "public/data/ucl_services.json"

# ============================================================================
# æ™ºèƒ½æŸ¥è¯¢éªŒè¯
# ============================================================================

def is_valid_query(query: str) -> tuple[bool, str]:
    """éªŒè¯æŸ¥è¯¢æ˜¯å¦æœ‰æ„ä¹‰
    
    Returns:
        (is_valid, reason)
    """
    if not query or len(query.strip()) < 2:
        return False, "too_short"
    
    query_lower = query.lower().strip()
    
    # 1. æ£€æµ‹æµ‹è¯•æŸ¥è¯¢
    test_queries = [
        'test', 'hello', 'hi', 'hey', 'testing', 
        'æµ‹è¯•', 'ä½ å¥½', 'ã“ã‚“ã«ã¡ã¯'
    ]
    if query_lower in test_queries:
        return False, "test_query"
    
    # 2. æ£€æµ‹å•ä¸ªæ— æ„ä¹‰è¯
    meaningless = [
        'a', 'the', 'is', 'are', 'what', 'how',
        'why', 'when', 'where', 'who'
    ]
    if query_lower in meaningless:
        return False, "meaningless"
    
    # 3. æ£€æµ‹æ˜¯å¦åŒ…å«å®è´¨æ€§å†…å®¹
    words = re.findall(r'\b[a-zA-Z]+\b', query_lower)
    stopwords = {'the', 'is', 'are', 'what', 'how', 'a', 'an', 'in', 'on', 'at', 'to', 'for'}
    meaningful_words = [w for w in words if w not in stopwords and len(w) > 2]
    
    if len(meaningful_words) == 0:
        return False, "no_meaningful_words"
    
    return True, "valid"

def get_friendly_response(query: str, reason: str, language: str = "en") -> str:
    """ä¸ºæ— æ•ˆæŸ¥è¯¢ç”Ÿæˆå‹å¥½å›åº”"""
    if language == "zh":
        responses = {
            "test_query": "ä½ å¥½ï¼æˆ‘æ˜¯ UCL AI åŠ©æ‰‹ ğŸ‘‹\n\næˆ‘å¯ä»¥å¸®ä½ è§£ç­”å…³äº UCL çš„é—®é¢˜ï¼Œæ¯”å¦‚ï¼š\nâ€¢ ä¸“ä¸šè¯¾ç¨‹ä¿¡æ¯\nâ€¢ å…¥å­¦è¦æ±‚\nâ€¢ å­¦è´¹å’Œå¥–å­¦é‡‘\nâ€¢ æ ¡å›­æœåŠ¡\n\nè¯·é—®æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„ï¼Ÿ",
            "too_short": "ä½ çš„é—®é¢˜å¤ªçŸ­äº†ï¼Œæˆ‘æ— æ³•ç†è§£ã€‚è¯·è¯¦ç»†æè¿°ä¸€ä¸‹ä½ æƒ³äº†è§£ä»€ä¹ˆï¼Ÿ",
            "meaningless": "è¯·é—®ä½ æƒ³äº†è§£ UCL çš„ä»€ä¹ˆä¿¡æ¯ï¼Ÿ\n\næ¯”å¦‚ï¼š\nâ€¢ æ•°æ®ç§‘å­¦ä¸“ä¸šçš„è¯¾ç¨‹ï¼Ÿ\nâ€¢ å…¥å­¦è¯­è¨€è¦æ±‚ï¼Ÿ\nâ€¢ å¥–å­¦é‡‘ä¿¡æ¯ï¼Ÿ",
            "no_meaningful_words": "æˆ‘æ²¡ç†è§£ä½ çš„é—®é¢˜ã€‚èƒ½å¦æ¢ä¸ªæ–¹å¼è¡¨è¾¾ï¼Ÿ"
        }
        return responses.get(reason, "è¯·æ¢ä¸ªæ–¹å¼æé—®")
    else:
        responses = {
            "test_query": "Hello! I'm UCL AI Assistant ğŸ‘‹\n\nI can help you with:\nâ€¢ Program information\nâ€¢ Entry requirements\nâ€¢ Fees & funding\nâ€¢ Campus services\n\nWhat would you like to know?",
            "too_short": "Your query is too short. Could you elaborate?",
            "meaningless": "What would you like to know about UCL?\n\nFor example:\nâ€¢ Course modules?\nâ€¢ Entry requirements?\nâ€¢ Scholarships?",
            "no_meaningful_words": "I didn't understand your query. Could you rephrase?"
        }
        return responses.get(reason, "Please rephrase your question")

# ============================================================================
# æ”¹è¿›çš„æ„å›¾è¯†åˆ«
# ============================================================================

def detect_intent_smart(query: str) -> str:
    """æ™ºèƒ½æ„å›¾è¯†åˆ«"""
    ql = query.lower()
    
    # å¤šçº§æ£€æµ‹ - ä»å…·ä½“åˆ°ä¸€èˆ¬
    
    # 1. è¯­è¨€/å…¥å­¦è¦æ±‚ç›¸å…³
    if any(k in ql for k in ['ielts', 'toefl', 'language requirement', 'english requirement', 
                              'è¯­è¨€è¦æ±‚', 'language proficiency', 'language test']):
        return 'language_requirements'
    
    # 2. ä¸€èˆ¬å…¥å­¦è¦æ±‚
    if any(k in ql for k in ['entry requirement', 'admission', 'qualification', 'prerequisite',
                              'å…¥å­¦', 'ç”³è¯·', 'requirement']):
        return 'requirements'
    
    # 3. è¯¾ç¨‹æ¨¡å—
    if any(k in ql for k in ['module', 'course', 'curriculum', 'syllabus', 'core',
                              'è¯¾ç¨‹', 'æ¨¡å—', 'compulsory']):
        return 'modules'
    
    # 4. å­¦è´¹è´¹ç”¨
    if any(k in ql for k in ['fee', 'tuition', 'cost', 'price', 'funding', 'scholarship',
                              'å­¦è´¹', 'è´¹ç”¨', 'å¥–å­¦é‡‘']):
        return 'fees'
    
    # 5. èŒä¸š/å°±ä¸š
    if any(k in ql for k in ['career', 'job', 'employment', 'graduate outcome',
                              'å°±ä¸š', 'èŒä¸š', 'placement']):
        return 'career'
    
    # 6. æœåŠ¡æ”¯æŒ
    if any(k in ql for k in ['service', 'support', 'counseling', 'help', 'guidance',
                              'æœåŠ¡', 'æ”¯æŒ', 'å’¨è¯¢']):
        return 'services'
    
    # 7. ä¸“ä¸šæ¯”è¾ƒ
    if ' vs ' in ql or ' versus ' in ql or 'æ¯”è¾ƒ' in ql or 'compare' in ql:
        return 'comparison'
    
    return 'general'

# ============================================================================
# æ”¹è¿›çš„ä¸Šä¸‹æ–‡æ„å»º
# ============================================================================

def build_smart_context(results: List[Dict], query: str, intent: str) -> str:
    """æ™ºèƒ½æ„å»ºä¸Šä¸‹æ–‡ - åªæå–çœŸæ­£ç›¸å…³çš„å†…å®¹"""
    if not results:
        return ""
    
    snippets = []
    query_lower = query.lower()
    
    for idx, result in enumerate(results[:3], 1):  # åªç”¨å‰3ä¸ªæœ€ç›¸å…³çš„
        doc = result.get("doc", {})
        title = doc.get("title", "Unknown")
        sections = result.get("matched_sections", [])
        
        if not sections:
            continue
        
        # ç­›é€‰çœŸæ­£ç›¸å…³çš„ç« èŠ‚
        relevant_sections = []
        for section in sections[:3]:  # æ¯ä¸ªæ–‡æ¡£æœ€å¤š3ä¸ªç« èŠ‚
            if not isinstance(section, dict):
                continue
            
            heading = section.get("heading", "").lower()
            text = section.get("text", "")
            
            if not text or len(text) < 50:
                continue
            
            # æ£€æŸ¥ç›¸å…³æ€§
            relevance_score = 0
            
            # æ ‡é¢˜ç›¸å…³æ€§
            if any(word in heading for word in query_lower.split() if len(word) > 3):
                relevance_score += 2
            
            # æ„å›¾åŒ¹é…
            intent_keywords = {
                'language_requirements': ['ielts', 'toefl', 'english', 'language level'],
                'requirements': ['entry', 'requirement', 'qualification', 'admission'],
                'modules': ['module', 'course', 'curriculum', 'compulsory'],
                'fees': ['fee', 'tuition', 'cost', 'scholarship'],
            }
            
            if intent in intent_keywords:
                if any(kw in heading or kw in text.lower()[:200] 
                       for kw in intent_keywords[intent]):
                    relevance_score += 3
            
            if relevance_score >= 2:  # åªä¿ç•™ç›¸å…³çš„
                relevant_sections.append({
                    'heading': section.get('heading', ''),
                    'text': text[:400],  # é™åˆ¶é•¿åº¦
                    'score': relevance_score
                })
        
        if relevant_sections:
            # æŒ‰ç›¸å…³æ€§æ’åº
            relevant_sections.sort(key=lambda x: x['score'], reverse=True)
            
            doc_text = f"[{idx}] {title}\n"
            for sec in relevant_sections[:2]:  # æ¯ä¸ªæ–‡æ¡£æœ€å¤š2ä¸ªæœ€ç›¸å…³ç« èŠ‚
                if sec['heading']:
                    doc_text += f"â€¢ {sec['heading']}: {sec['text']}\n"
                else:
                    doc_text += f"â€¢ {sec['text']}\n"
            
            snippets.append(doc_text)
    
    context = "\n\n".join(snippets)
    logger.info(f"ğŸ“ Smart context: {len(context)} chars from {len(snippets)} docs")
    return context

# ============================================================================
# æ”¹è¿›çš„ LLM Prompt
# ============================================================================

def generate_smart_answer(
    query: str,
    context: str,
    intent: str,
    language: str = "en"
) -> str:
    """ä½¿ç”¨æ”¹è¿›çš„ Prompt ç”Ÿæˆæ™ºèƒ½ç­”æ¡ˆ"""
    
    if not context:
        if language == "zh":
            return "æŠ±æ­‰ï¼Œæˆ‘æ‰¾ä¸åˆ°ç›¸å…³ä¿¡æ¯ã€‚\n\nå»ºè®®ï¼š\nâ€¢ è®¿é—® UCL å®˜ç½‘è·å–æœ€æ–°ä¿¡æ¯\nâ€¢ æ¢ä¸ªæ–¹å¼æè¿°ä½ çš„é—®é¢˜\nâ€¢ è”ç³» UCL æ‹›ç”ŸåŠ"
        return "Sorry, I couldn't find relevant information.\n\nSuggestions:\nâ€¢ Visit UCL website\nâ€¢ Rephrase your question\nâ€¢ Contact UCL admissions"
    
    # æ„å»ºæ™ºèƒ½ Prompt
    if language == "zh":
        system = """ä½ æ˜¯ UCL æ™ºèƒ½åŠ©æ‰‹ï¼Œä¸“é—¨å›ç­”å…³äº UCL çš„é—®é¢˜ã€‚

æ ¸å¿ƒåŸåˆ™:
1. åªå›ç­”ä¸ UCL ç›¸å…³çš„é—®é¢˜
2. ç›´æ¥ç»™å‡ºç­”æ¡ˆï¼Œä¸è¦è¯´"æ ¹æ®æ–‡æ¡£"ã€"æ–‡æ¡£æ˜¾ç¤º"ç­‰åºŸè¯
3. ç”¨ç®€æ´çš„è¦ç‚¹å½¢å¼ï¼ˆâ€¢ï¼‰åˆ—å‡ºå…³é”®ä¿¡æ¯
4. å¦‚æœä¿¡æ¯ä¸å®Œæ•´ï¼Œè¯šå®å‘ŠçŸ¥å¹¶å»ºè®®è®¿é—®å®˜ç½‘
5. 100-150å­—å†…å®Œæˆå›ç­”

ç¦æ­¢:
âŒ "æ–‡æ¡£ä¸­æåˆ°..."
âŒ "æ ¹æ®æä¾›çš„ä¿¡æ¯..."
âŒ é‡å¤é—®é¢˜
âŒ è¿‡åº¦å•°å—¦"""

        user = f"""ä¿¡æ¯æ¥æº:
{context}

ç”¨æˆ·é—®é¢˜: {query}

è¦æ±‚:
1. ç›´æ¥å›ç­”é—®é¢˜
2. ç”¨ â€¢ åˆ—å‡ºå…³é”®è¦ç‚¹
3. 100-150å­—
4. çº¯ä¸­æ–‡"""
    
    else:
        system = """You are UCL AI Assistant, specialized in answering UCL-related questions.

Core principles:
1. Answer only UCL-related questions
2. Give direct answers, no "according to documents" nonsense
3. Use bullet points (â€¢) for key information
4. If incomplete info, be honest and suggest visiting website
5. Keep under 150 words

Forbidden:
âŒ "The documents mention..."
âŒ "Based on provided information..."
âŒ Repeating the question
âŒ Being overly verbose"""

        user = f"""Information:
{context}

Question: {query}

Requirements:
1. Answer directly
2. Use â€¢ for key points
3. Under 150 words
4. English only"""
    
    messages = [
        {"role": "system", "content": system},
        {"role": "user", "content": user}
    ]
    
    # è°ƒç”¨ LLM
    try:
        if groq_configured():
            logger.info(f"ğŸ¤– LLM call (lang={language}, intent={intent})...")
            # NEW: è®¾ç½®ä¸€ä¸ªæ¸©å’Œçš„è¶…å‚æ•°ï¼Œé˜²æ­¢è¾“å‡ºè¿‡é•¿æˆ–å¤±æ§
            answer = chat_with_groq(messages, temperature=0.1)  # ä¿æŒä½ åŸè®¾å®š
            
            # åå¤„ç† - ç§»é™¤å¸¸è§åºŸè¯
            forbidden_phrases = [
                "according to the documents",
                "based on the information provided",
                "the documents mention",
                "æ ¹æ®æ–‡æ¡£",
                "æ–‡æ¡£ä¸­æåˆ°",
                "æä¾›çš„ä¿¡æ¯æ˜¾ç¤º"
            ]
            low = answer.lower()
            for phrase in forbidden_phrases:
                if phrase in low:
                    logger.warning(f"âš ï¸  Found forbidden phrase: {phrase}")
                    # NEW: æ›´ç¨³å¥çš„æ¸…ç†ï¼Œä¸ä¼šè¯¯åˆ æ•´æ®µ
                    answer = re.sub(rf"\b{re.escape(phrase)}\b[:,ï¼Œ]?\s*", "", answer, flags=re.IGNORECASE)
                    low = answer.lower()
            return answer.strip()
        
    except Exception as e:
        logger.error(f"âŒ LLM failed: {e}")
    
    # Fallback
    if language == "zh":
        return "æŠ±æ­‰ï¼Œæš‚æ—¶æ— æ³•ç”Ÿæˆå›ç­”ã€‚è¯·è®¿é—® UCL å®˜ç½‘æˆ–è”ç³»æ‹›ç”ŸåŠã€‚"
    return "Sorry, unable to generate answer. Please visit UCL website or contact admissions."

# ============================================================================
# ä¸»å‡½æ•°
# ============================================================================

@lru_cache(maxsize=1)
def _load_documents() -> List[Dict]:
    """åŠ è½½æ–‡æ¡£"""
    documents = []
    for path, name in [(PROGRAMS_PATH, "programs"), (SERVICES_PATH, "services")]:
        if not path.exists():
            continue
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = json.load(f)
                documents.extend(data)
            logger.info(f"âœ… Loaded {len(data)} {name}")
        except Exception as e:
            logger.error(f"âŒ Load {name} failed: {e}")
    return documents

def _normalize_lang(query: str, language: str) -> str:
    """NEW: è½»é‡çš„è¯­è¨€å½’ä¸€åŒ–ï¼Œä¿æŒä½ åŸæœ‰è‡ªåŠ¨æ£€æµ‹é€»è¾‘"""
    if language and language in ("zh", "en"):
        return language
    chinese_chars = len(re.findall(r'[\u4e00-\u9fff]', query))
    return "zh" if chinese_chars > 0 else "en"

def _web_fallback(query: str, top_k: int, intent: str, language: str = "en") -> List[Dict]:
    """NEW: å½“æœ¬åœ°æ£€ç´¢ä¸ºç©ºæ—¶ï¼Œä¼˜å…ˆä½¿ç”¨ä½ å·²æœ‰çš„ search_web åšå›é€€"""
    if not HAVE_WEB_SEARCH:
        return []
    try:
        # è¿™é‡Œå‡è®¾ search_web è¿”å›: [{'title','url','snippet'æˆ–'text'}, ...]
        web_hits = search_web(query, language=language)  # å…¼å®¹ä½ çš„å®ç°
        results = []
        for w in (web_hits or [])[:top_k]:
            snippet = w.get("snippet") or w.get("text") or ""
            if not snippet:
                continue
            results.append({
                "doc": {
                    "title": w.get("title", "Web result"),
                    "url": w.get("url", ""),
                },
                "score": w.get("score", 0),
                "intent": intent,
                "matched_sections": [{"heading": "", "text": snippet[:600]}],
                "source": "web"
            })
        if results:
            logger.info(f"ğŸŒ Web fallback used: {len(results)} results")
        return results
    except Exception as e:
        logger.error(f"âŒ Web fallback failed: {e}")
        return []

